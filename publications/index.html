<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> publications | Dr. Mohammad Rezaalipour </title> <meta name="author" content="Mohammad Rezaalipour"> <meta name="description" content="My publications by categories in reversed chronological order."> <meta name="keywords" content="software-analysis, test-generation, fault-localization, program-repair, annotest, fauxpy, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://mohrez86.github.io/publications/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Dr. Mohammad Rezaalipour </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/news/">news </a> </li> <li class="nav-item active"> <a class="nav-link" href="/publications/">publications <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">talks </a> </li> <li class="nav-item "> <a class="nav-link" href="/service/">service </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> </header> <article> <h1 id="publications">Publications</h1> <p>The following is a list of my publications categorized in reverse chronological order. In the details section, you can also find additional materials for each study, such as replication packages or tools I developed as part of each study.</p> <hr> <h4 id="journal-articles">Journal Articles</h4> <ul> <li><a href="#an-empirical-study-of-fault-localization-in-python-programs">An empirical study of fault localization in Python programs</a></li> <li><a href="#doctor-code-a-machine-learning-based-approach-to-program-repair">Doctor Code: A machine learning-based approach to program repair</a></li> <li><a href="#an-annotation-based-approach-for-finding-bugs-in-neural-network-programs">An annotation-based approach for finding bugs in neural network programs</a></li> <li><a href="#axmap-making-approximate-adders-aware-of-input-patterns">AxMAP: Making Approximate Adders Aware of Input Patterns</a></li> <li><a href="#idrax-a-tool-chain-for-designing-efficient-approximate-adders">IDrAx: A tool-chain for designing efficient approximate adders</a></li> </ul> <h4 id="conference-proceedings">Conference Proceedings</h4> <ul> <li><a href="#annotest-an-annotation-based-test-generation-tool-for-neural-network-programs">aNNoTest: An Annotation-based Test Generation Tool for Neural Network Programs</a></li> <li><a href="#an-approach-to-generate-effective-fault-localization-methods-for-programs">An Approach to Generate Effective Fault Localization Methods for Programs</a></li> <li><a href="#arselda-an-improvement-on-adaptive-random-testing-by-adaptive-region-selection">Arselda: An Improvement on Adaptive Random Testing by Adaptive Region Selection</a></li> </ul> <h4 id="technical-reports">Technical Reports</h4> <ul> <li><a href="#fauxpy-a-fault-localization-tool-for-python">FauxPy: A Fault Localization Tool for Python</a></li> </ul> <h4 id="phd-thesis">PhD Thesis</h4> <ul> <li><a href="#test-case-generation-and-fault-localization-for-data-science-programs">Test case generation and fault localization for data science programs</a></li> </ul> <hr> <h2 id="details">Details</h2> <hr> <h3 id="an-empirical-study-of-fault-localization-in-python-programs">An empirical study of fault localization in Python programs</h3> <p>Mohammad Rezaalipour and Carlo A. Furia<br> Empirical Software Engineering<br> 2024</p> <ul> <li> <a href="https://doi.org/10.1007/s10664-024-10475-3" rel="external nofollow noopener" target="_blank">DOI</a> | <a href="https://arxiv.org/abs/2305.19834" rel="external nofollow noopener" target="_blank">arXiv</a> | <a href="https://github.com/atom-sw/fauxpy-experiments" rel="external nofollow noopener" target="_blank">GitHub</a> | <a href="https://fauxpy.readthedocs.io" rel="external nofollow noopener" target="_blank">FauxPy Documentation</a> </li> </ul> <p><strong>Abstract:</strong></p> <p>Despite its massive popularity as a programming language, especially in novel domains like data science programs, there is comparatively little research about fault localization that targets Python. Even though it is plausible that several findings about programming languages like C/C++ and Java—the most common choices for fault localization research—carry over to other languages, whether the dynamic nature of Python and how the language is used in practice affect the capabilities of classic fault localization approaches remain open questions to investigate.</p> <p>This paper is the first multi-family large-scale empirical study of fault localization on real-world Python programs and faults. Using Zou et al.’s recent large-scale empirical study of fault localization in Java <a href="https://doi.org/10.1109/TSE.2019.2892102" rel="external nofollow noopener" target="_blank">(Zou et al. 2021)</a> as the basis of our study, we investigated the effectiveness (i.e., localization accuracy), efficiency (i.e., runtime performance), and other features (e.g., different entity granularities) of seven well-known fault-localization techniques in four families (spectrum-based, mutation-based, predicate switching, and stack-trace based) on 135 faults from 13 open-source Python projects from the BugsInPy curated collection <a href="https://doi.org/10.1145/3368089.3417943" rel="external nofollow noopener" target="_blank">(Widyasari et al. 2020)</a>.</p> <p>The results replicate for Python several results known about Java, and shed light on whether Python’s peculiarities affect the capabilities of fault localization. The replication package that accompanies this paper includes detailed data about our experiments, as well as the tool FauxPy that we implemented to conduct the study.</p> <hr> <h3 id="test-case-generation-and-fault-localization-for-data-science-programs">Test case generation and fault localization for data science programs</h3> <p>Mohammad Rezaalipour<br> PhD Thesis, Università della Svizzera italiana<br> 2024</p> <ul> <li> <a href="https://n2t.net/ark:/12658/srd1328869" rel="external nofollow noopener" target="_blank">Thesis Link</a> | <a href="../files/phd_thesis_2024.pdf">Slides</a> | <a href="https://www.usi.ch/en/feeds/28574" rel="external nofollow noopener" target="_blank">Announcement</a> </li> </ul> <p><strong>Abstract:</strong></p> <p>Data science refers to inter-disciplinary approaches designed to extract knowledge from vast amounts of data. It combines techniques from fields such as statistics and machine learning to develop novel applications for different science and engineering domains. Data science approaches are implemented as programs usually written in languages such as R or Python, collectively referred to as data science programs. Due to their inter-disciplinary usages, these programs are often written by domain experts possibly unfamiliar with the best practices of software development, and thus, they may exhibit low quality. In fact, there is evidence that these programs contain several bugs, often different in nature compared to those found in traditional programs. As a result, data science programs challenge conventional debugging techniques such as those from test generation and fault localization activities, due to the unique nature of bugs found in them. Additionally, being written in dynamically typed languages such as Python adds to the difficulties of testing and analyzing them.</p> <p>These challenges call for research into new debugging techniques tailored specifically for these programs, which is the focus of the current dissertation. Precisely, this thesis aims to understand the capabilities and limitations of standard test generation and fault localization techniques on data science programs implemented in dynamic languages such as Python. To achieve this goal, the dissertation presents contributions in three areas: i) a test generation technique for neural network (NN) programs, a wide spread class of data science programs; ii) an empirical study of fault localization in Python programs; and iii) two debugging tools and a curated dataset of NN bugs.</p> <p>In the first area, we investigated and identified the limitations of general-purpose test generation techniques on NN programs, which led to the development of aNNoTest, a novel test generation technique tailored for NN programs. We evaluated aNNoTest on 19 open-source programs, demonstrating its effectiveness at finding bugs in real-world NN programs. In the second area, we conducted the first large-scale multi-family empirical study of fault localization in Python programs. Targeting 135 bugs from 13 projects, we studied seven fault localization techniques from four families along with combinations of them. We considered different fault localization granularity levels and measured both effectiveness and efficiency in our analyses. In the third area, we developed: i) the aNNoTest tool, an implementation of the aNNoTest approach mentioned above; ii) FauxPy, to our knowledge, the first open-source multi-family fault localization tool for Python; and iii) a curated dataset of NN bugs, for which aNNoTest was used to generate tests.</p> <p>Along with supporting the domain with the tools and techniques we developed, we hope our contributions will be beneficial to inform the development of more effective debugging techniques for Python data science programs.</p> <hr> <h3 id="fauxpy-a-fault-localization-tool-for-python">FauxPy: A Fault Localization Tool for Python</h3> <p>Mohammad Rezaalipour and Carlo A. Furia<br> arXiv Technical Report<br> 2024</p> <ul> <li> <a href="https://arxiv.org/abs/2404.18596" rel="external nofollow noopener" target="_blank">arXiv</a> | <a href="https://github.com/atom-sw/fauxpy" rel="external nofollow noopener" target="_blank">FauxPy GitHub</a> | <a href="https://fauxpy.readthedocs.io" rel="external nofollow noopener" target="_blank">FauxPy Documentation</a> | <a href="https://www.youtube.com/watch?v=6ooPPiwd79g" rel="external nofollow noopener" target="_blank">YouTube</a> </li> </ul> <p><strong>Abstract:</strong></p> <p>This paper presents FauxPy, a fault localization tool for Python programs. FauxPy supports seven well-known fault localization techniques in four families: spectrum-based, mutation-based, predicate switching, and stack trace fault localization. It is implemented as plugin of the popular Pytest testing framework, but also works with tests written for Unittest and Hypothesis (two other popular testing frameworks). The paper showcases how to use FauxPy on two illustrative examples, and then discusses its main features and capabilities from a user’s perspective. To demonstrate that FauxPy is applicable to analyze Python projects of realistic size, the paper also summarizes the results of an extensive experimental evaluation that applied FauxPy to 135 real-world bugs from the BugsInPy curated collection. To our knowledge, FauxPy is the first open-source fault localization tool for Python that supports multiple fault localization families.</p> <hr> <h3 id="doctor-code-a-machine-learning-based-approach-to-program-repair">Doctor Code: A machine learning-based approach to program repair</h3> <p>Sharmin Moosavi, Mojtaba Vahidi-Asl, Hassan Haghighi, and Mohammad Rezaalipour<br> Scientia Iranica<br> 2024</p> <ul> <li><a href="https://doi.org/10.24200/sci.2023.54718.3884" rel="external nofollow noopener" target="_blank">DOI</a></li> </ul> <p><strong>Abstract:</strong></p> <p>To address the problems of automatic repair techniques, we present Doctor Code, a new APR technique that chooses repair operators by systematically learning from the features of the most common bugs in different programs, using machine learning. The wise selection of repair operators reduces the number of candidate patches. We compare our technique against Mutation repair, a test suite-based APR technique, using the Siemens suite. The experiment results indicate that our technique can fix 41 bugs while the baseline only repairs 22. In addition, Doctor Code can produce patches that do not exist in the search space of the three test suite-based techniques called SPR, Prophet, and SemFix. We also experiment with Doctor Code utilizing three buggy versions of a program called Space (9K LOC), to indicate its capability of repairing large-sized programs. In addition, we compare Doctor Code against 7 state-of-the-art APR tools like Elixir, using the Defects4j dataset. The experiment results indicate that our technique outperforms the other tools regarding the number of fixed bugs and overfitted patches.</p> <p>Comparing Doctor Code with RAPR as the baseline indicates that using machine learning reduces the number of overfitted patches and the time of patch production by 33.33% and 82.68%, respectively.</p> <hr> <h3 id="annotest-an-annotation-based-test-generation-tool-for-neural-network-programs">aNNoTest: An Annotation-based Test Generation Tool for Neural Network Programs</h3> <p>Mohammad Rezaalipour and Carlo A. Furia<br> Proceedings of the 39th IEEE International Conference on Software Maintenance and Evolution (ICSME)<br> 2023</p> <ul> <li> <a href="https://doi.org/10.1109/ICSME58846.2023.00075" rel="external nofollow noopener" target="_blank">DOI</a> | <a href="https://github.com/atom-sw/annotest" rel="external nofollow noopener" target="_blank">aNNoTest</a> | <a href="https://github.com/atom-sw/annotest-subjects" rel="external nofollow noopener" target="_blank">NN Bugs Dataset</a> </li> </ul> <p><strong>Abstract:</strong></p> <p>Even though neural network (NN) programs are often written in Python, using general-purpose test-generation tools for Python to test them is likely to be ineffective, as these tools do not support the particular input constraints that NN programs often require. To address this challenge, we present aNNoTest: an automated unit-test generation tool for NN programs written in Python. aNNoTest offers a simple annotation language that is suitable to concisely express the usual input constraints of NN programs; it then uses these annotations to precisely generate valid inputs that are capable of revealing bugs. This short paper describes how aNNoTest works in practice, and reports some experiments that demonstrate its effectiveness as a bug-finding tool for NN programs. aNNoTest is available as open source.</p> <hr> <h3 id="an-annotation-based-approach-for-finding-bugs-in-neural-network-programs">An annotation-based approach for finding bugs in neural network programs</h3> <p>Mohammad Rezaalipour and Carlo A. Furia<br> Journal of Systems and Software<br> 2023</p> <ul> <li> <a href="https://doi.org/10.1016/j.jss.2023.111669" rel="external nofollow noopener" target="_blank">DOI</a> | <a href="https://github.com/atom-sw/annotest" rel="external nofollow noopener" target="_blank">aNNoTest</a> | <a href="https://github.com/atom-sw/annotest-subjects" rel="external nofollow noopener" target="_blank">NN Bugs Dataset</a> </li> </ul> <p><strong>Abstract:</strong></p> <p>As neural networks are increasingly included as core components of safety–critical systems, developing effective testing techniques specialized for them becomes crucial. The bulk of the research has focused on testing neural-network models; but these models are defined by writing programs, and there is growing evidence that these neural-network programs often have bugs too.</p> <p>This paper presents aNNoTest: an approach to generating test inputs for neural-network programs. A fundamental challenge is that the dynamically-typed languages (e.g., Python) commonly used to program neural networks cannot express detailed constraints about valid function inputs (e.g., matrices with certain dimensions). Without knowing these constraints, automated test-case generation is prone to producing invalid inputs, which trigger spurious failures and are useless for identifying real bugs. To address this problem, we introduce a simple annotation language tailored for concisely expressing valid function inputs in neural-network programs. aNNoTest takes as input an annotated program, and uses property-based testing to generate random inputs that satisfy the validity constraints. In the paper, we also outline guidelines that simplify writing aNNoTest annotations.</p> <p>We evaluated aNNoTest on 19 neural-network programs from Islam et al’s survey <a href="https://doi.org/10.1145/3338906.3338955" rel="external nofollow noopener" target="_blank">(Islam et al. 2019)</a>, which we manually annotated following our guidelines—producing 6 annotations per tested function on average. aNNoTest automatically generated test inputs that revealed 94 bugs, including 63 bugs that the survey reported for these projects. These results suggest that aNNoTest can be a valuable approach to finding widespread bugs in real-world neural-network programs.</p> <hr> <h3 id="axmap-making-approximate-adders-aware-of-input-patterns">AxMAP: Making Approximate Adders Aware of Input Patterns</h3> <p>Morteza Rezaalipour, Mohammad Rezaalipour, Masoud Dehyadegari, and Mahdi Nazm Bojnordi<br> IEEE Transactions on Computers<br> 2020</p> <ul> <li> <a href="https://doi.org/10.1109/TC.2020.2968905" rel="external nofollow noopener" target="_blank">DOI</a> | <a href="https://github.com/mohrez86/AxMAP" rel="external nofollow noopener" target="_blank">GitHub</a> </li> </ul> <p><strong>Abstract:</strong></p> <p>Making approximate computing specific to user requirements is crucial to system performance, energy-efficiency, and reliability. However, developing hardware for such optimization becomes a significant challenge due to the high cost of examining all potential choices while exploring a large design space. One determinant aspect of exploring a design space is the efficiency of evaluating error metrics, such as the Mean Error Distance (MED) and the Error Probability (EP), for each possible choice within the search space. Since computing these error-metrics is quite time-consuming, efficient calculation approaches are essential. This article proposes a novel formal approach to accurately compute the EP and MED of approximate adders for any input pattern at a linear time and space complexity. Our experimental results indicate that the proposed approach can accurately compute the error-metrics of large approximate adders at a 150 times faster speed compared to the Monte Carlo sampling methods. We then develop AxMAP, a design tool based on the proposed error-metrics computation that generates energy-efficient approximate adders for any given input pattern. When applied to image processing applications, AxMAP produces more than 150 different designs for adders that achieve superior performance and energy-efficiency compared to the existing state-of-the-art approximate adders.</p> <hr> <h3 id="idrax-a-tool-chain-for-designing-efficient-approximate-adders">IDrAx: A tool-chain for designing efficient approximate adders</h3> <p>Morteza Rezaalipour, Mohammad Rezaalipour, Sarvenaz Tajasob, and Masoud Dehyadegari<br> Microelectronics Journal<br> 2019</p> <ul> <li><a href="https://doi.org/10.1016/j.mejo.2019.06.011" rel="external nofollow noopener" target="_blank">DOI</a></li> </ul> <p><strong>Abstract:</strong></p> <p>As transistors shrink down, improving the energy-efficiency of nanometer ICs has gained a great deal of attention. Recently, approximate computing has been introduced to address energy-efficiency problems of error-tolerant systems. Adders are the most widely used arithmetic modules that consume significant amounts of system’s total energy and area. The error-resiliency of these systems has made it possible to innovate energy-efficiency approximate adders to obtain low power and high-speed circuits. This paper presents IDrAx, an approach to improve the accuracy of approximate adders. The goal is to find the most significant errors in the error distribution for the given circuit and correct them through low-cost additional circuits. The proposed method is applied to several state-of-the-art approximate adders for evaluation by considering two different input distributions. Our simulation results indicate that the proposed design achieves by 75% and 78.01% accuracy regarding mean error distance metric for uniform and normal input distributions, respectively.</p> <hr> <h3 id="an-approach-to-generate-effective-fault-localization-methods-for-programs">An Approach to Generate Effective Fault Localization Methods for Programs</h3> <p>Babak Bagheri, Mohammad Rezaalipour, and Mojtaba Vahidi-Asl<br> Fundamentals of Software Engineering<br> 2019</p> <ul> <li><a href="https://doi.org/10.1007/978-3-030-31517-7_17" rel="external nofollow noopener" target="_blank">DOI</a></li> </ul> <p><strong>Abstract:</strong></p> <p>Software Debugging is a tedious and costly task in software development life-cycle. Thus, various automated fault localization approaches have been proposed to address this problem, among which, spectrum-based fault localization has attracted a lot of attention. Using various formulas, known as ranking metrics, spectrum-based fault localization techniques assign scores to the entities of programs (e.g., statements) based on their suspiciousness of being the root cause of failures. Despite the obvious advantages of spectrum-based fault localization techniques, such as being lightweight, they cannot effectively locate faults in every program owing to the fact that they do not consider the characteristics of the programs. We believe that program characteristics can be helpful at finding the right ranking metrics for programs, and they can assist at combining several existing ones to produce a customized ranking metric specific to a given program.</p> <p>In this paper, we have proposed an approach which combines 40 different ranking metrics to generate a new ranking metric specific to a given program. Employing mutation testing operators, the proposed approach retrieves information from the program and then, using different preferential voting systems, it combines various ranking metrics based on the collected information. We have evaluated our approach on 154 faulty versions from eight different programs of Space and Siemens test suite and compare it with nine state-of-the-art ranking metrics. The experimental results indicate that the ranking metrics generated by our approach is superior with respect to evaluation metrics such as the Exam score and TOP-N.</p> <hr> <h3 id="arselda-an-improvement-on-adaptive-random-testing-by-adaptive-region-selection">Arselda: An Improvement on Adaptive Random Testing by Adaptive Region Selection</h3> <p>Mohammad Rezaalipour, Lida Talebsafa, and Mojtaba Vahidi-Asl<br> 8th International Conference on Computer and Knowledge Engineering (ICCKE)<br> 2018</p> <ul> <li><a href="https://doi.org/10.1109/ICCKE.2018.8566625" rel="external nofollow noopener" target="_blank">DOI</a></li> </ul> <p><strong>Abstract:</strong></p> <p>Distance-aware Forgetting Fixed Size Candidate Set (DF-FSCS) is an Adaptive Random Testing (ART) technique, which lowers the computational overhead of Fixed Size Candidate Set ART (FSCS-ART), using a forgetting strategy. DF-FSCS partitions the input domain into regions, and while computing the distance of a candidate test case from executed test cases, as a vector in the input domain, it only considers test cases that are in the same region as the candidate. Although being a lightweight technique, there are two issues with DF-FSCS. First, it does not attempt to generate test cases in low-density regions, which if done, could result in a more even spread of test cases. Second, the regions it defines are smaller at the lower or upper boundaries of input domains, which declines the quality of test cases produced in these regions.</p> <p>We propose Arselda, an APR technique that improves DF-FSCS. By generating test cases in low-density regions that have a fewer number of test cases and enlarging regions at lower or upper boundaries of input domains, Arselda addresses the two issues mentioned above. Considering DF-FSCS as the baseline, a simulation analysis has been performed to evaluate the effectiveness of Arselda. According to the experiment results, Arselda has better failure detection effectiveness compared with the baseline for the block failure pattern. Also, Arselda has lower computational overhead than the baseline.</p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Mohammad Rezaalipour. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: March 23, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>